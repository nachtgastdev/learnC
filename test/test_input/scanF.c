//-----------------------------------------------------------------------
//----------------------read_string_and_allocate-------------------------
//-----------------------------------------------------------------------
//Чтение строки произвольной длины из потока ввода

#include "head.h"

char * read_string_and_allocate ()
{
    int buffer_size = 64 ;//Размер буфера для чтения
    int buffer_size_divizer = 1 ; //Делитель для размера буфера. Изначально равен 1, далее станет понятно почему
    int offset_in_buffer = 0 ; //Смещение в буфере изначально равно нулю
    int length ;
    char * buffer = (char*)malloc ( buffer_size ) ; //Выделяем память под буфер
 
    if ( buffer == NULL ) //Если не удалось выделить, то
    {
        return NULL ; //Возвращаем ноль
    }
    buffer[0] = '\0' ;
    //Цикл до тех пор, пока не считаем всю строку целиком в буфер
    while ( 1 )
    {
        //Считываем строку из потока ввода
        //Причем считываем в буфер, со смещением равным offset_in_buffer
        //В качестве размера буфера передаем отношение размера буфера к делителю(buffer_size_divizer)
        if ( fgets( buffer + offset_in_buffer , buffer_size/buffer_size_divizer , stdin ) == NULL )
        {
            //Если нарвались на ошибку чтения, то выводим сообщение об ошибке
            printf ("\nRead error. Please, try again\n") ;
            fflush(stdout) ;//сбрасываем поток вывода
            fscanf ( stdin , "%*[^\n]" ) ; //Считываем символы, оставшиеся в потоке ввода
            free (buffer) ;//Освобождаем память, занятую буфером
            return NULL ; //Возвращаем ноль
        }
        else //Если прочитали успешно, то
        {
            //Вычисляем размер считанной строки (не считая '\0') и не считая ранее считанных символов (это контролируется смещением)
            length = strlen (buffer+offset_in_buffer) ;
            if ( buffer[length-1+offset_in_buffer] != '\n' ) //Если последний символ в строке (опять же, смещение контролирует начало отсчета, чтобы не считать уже считанные ранее символы) не равен '\n' ,
            //значит считали еще не все символы из потока
            {
                //Увеличиваем размер буфера равным в два раза больше текущего
                buffer_size *= 2 ;
                char * buffer_temp = buffer ;//Сохраняем указатель на буфер, чтобы в случае ошибки освободить память
                //Перевыделяем память нового размера
                //realloc сам скопирует старые даные в новую память
                buffer = (char*)realloc ( buffer , buffer_size ) ;
                if ( buffer == NULL ) //Если память выделить не удалось, то
                {
                    free ( buffer_temp ) ; //Освобождаем память
                    return NULL ; //вернем 0
                }
                //Теперь у нас доступна только половина буфера
                //ведь в первой половине буфера у нас находятся символы
                //уже считанные ранее, поэтому
 
                //К текущему смещению прибавляем длину строки, это
                //позволит потом считывать строку дальше в буфер со смещением, не задевая уже считанные символы
                offset_in_buffer += length ;
                //Устанавливаем делитель для размера буфера
                //это укажет, что теперь нам доступен не весь размер буфера, а лишь половина
                buffer_size_divizer = 2 ;
                //в результате это приведет к чтению только во вторую половину буфера без переполнения
            }
            else //Если же последний считанный символ равен '\n', то
            {
 
                buffer[length-1+offset_in_buffer] = '\0' ; //Заменяем символ конца строки на символ '\0'
                break ;//и выходим из цикла
            }
        }
    }
    return buffer ; //Возвращаем указатель на буфер со строкой
}
